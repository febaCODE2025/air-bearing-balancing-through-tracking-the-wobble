# CubeSat Air Bearing Balancing System

## üìã Project Summary

This system automatically balances a CubeSat mock-up on an air bearing table by:
1. **Detecting wobble** using computer vision (ArUco markers)
2. **Calculating the center of mass (CoM) offset** from the center of rotation (CoR)
3. **Providing a correction vector** to guide trim weight adjustments
4. **Iteratively improving balance** until the system is stable

**Result:** CoM offset reduced from ~18mm to <3mm in 3-5 iterations (~20 minutes)

---

## üìÇ File Overview

### **Core Scripts (Execute in Order)**

| File | Purpose | When to Use |
|------|---------|-------------|
| `take_calibration_photo.py` | Capture checkerboard photos for camera calibration | Once per camera setup |
| `calibrate_camera.py` | Calculate camera intrinsics and distortion coefficients | Once per camera setup |
| `basic_detection.py` | Test if ArUco markers are detected properly | Before each session (optional) |
| `track_wobble.py` | **Main script:** Track wobble and calculate correction vector | Every measurement (multiple times) |
| `Camera_Coordinate_System.py` | Visual tool to align camera with center of rotation | Setup phase (optional) |

### **Generated Files**

| File/Folder | Description | Generated By |
|-------------|-------------|--------------|
| `data/calib_images/*.png` | Checkerboard calibration photos | `take_calibration_photo.py` |
| `calib/camera_intrinsics.npz` | **Camera calibration data (REQUIRED)** | `calibrate_camera.py` |
| `data/markers_pixel_log.csv` | Pixel coordinates of all detected markers | `track_wobble.py` |
| `data/markers_real_world_log.csv` | Real-world (mm) coordinates of marker 0 | `track_wobble.py` |
| `data/final_path_plot_pixel.png` | Visualization in pixel space | `track_wobble.py` |
| `data/final_path_plot_mm.png` | Visualization in real-world coordinates (mm) | `track_wobble.py` |

---

## üßÆ Algorithm Overview

### **High-Level Process**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 1. Camera Calibration (One-time)                            ‚îÇ
‚îÇ    - Remove lens distortion                                 ‚îÇ
‚îÇ    - Calculate intrinsic parameters                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 2. Marker Detection & Tracking (Per Measurement)            ‚îÇ
‚îÇ    - Detect 5 ArUco markers (IDs 0-4)                       ‚îÇ
‚îÇ    - Track marker 0 path over 5 seconds                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 3. Coordinate Transformation                                ‚îÇ
‚îÇ    - Use 4 reference markers to establish coordinate system ‚îÇ
‚îÇ    - Transform marker 0 from pixels to millimeters          ‚îÇ
‚îÇ    - Apply perspective correction for height differences    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 4. Circle Fitting & Analysis                                ‚îÇ
‚îÇ    - Fit circle to marker 0 trajectory                      ‚îÇ
‚îÇ    - Circle center = CoM offset from CoR                    ‚îÇ
‚îÇ    - Calculate correction vector: magnitude & direction     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 5. Weight Adjustment (Manual)                               ‚îÇ
‚îÇ    - Move trim weights according to correction vector       ‚îÇ
‚îÇ    - Repeat steps 2-5 until balanced                        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### **Mathematical Principles**

#### **1. Coordinate Transformation (Homography)**
```
Pixel coordinates (u, v) ‚Üí Real-world coordinates (x, y)

H = Homography matrix calculated from 4 reference markers
[x]       [u]
[y] = H √ó [v]
[1]       [1]
```

#### **2. Perspective Correction**
Due to height differences between markers, we apply a scale correction:
```
scale_factor = (Z_CAM - Z_TABLE) / (Z_CAM - Z_MARKER0)

x_corrected = x_measured √ó scale_factor
y_corrected = y_measured √ó scale_factor
r_corrected = r_measured √ó scale_factor
```
Where:
- `Z_CAM` = Camera height above table
- `Z_TABLE` = Height from camera to table surface markers
- `Z_MARKER0` = Height from camera to marker 0 on CubeSat

#### **3. Circle Fitting (Least Squares)**
```
For N points (x_i, y_i), minimize:
Œ£[(‚àö((x_i - x_c)¬≤ + (y_i - y_c)¬≤) - r)¬≤]

Solution gives: (x_c, y_c, r)
- (x_c, y_c) = Circle center = CoM offset
- r = Circle radius = Wobble magnitude
```

#### **4. Correction Vector**
```
CoM must move to CoR (origin)
Correction vector = -1 √ó (x_c, y_c)

Magnitude = ‚àö(x_c¬≤ + y_c¬≤)
Direction = arctan2(y_c, x_c) in degrees
```

#### **5. Weight Displacement Formula**
```
To shift CoM by (N, M):
Œîx' = -(N √ó M_sys) / m
Œîy' = -(M √ó M_sys) / m

Where:
- M_sys = 8870 g (total system mass)
- m = 476 g (each trim weight)
- (Œîx', Œîy') = Distance to move each weight
```

---

## üõ†Ô∏è Installation

### **Required Hardware**
- Camera (2K resolution recommended: 2560√ó1440)
- 5 ArUco markers from DICT_4X4_100 dictionary (IDs 0-4)
- Checkerboard calibration pattern (9√ó6 inner corners, 25mm squares)
- Air bearing table with CubeSat mock-up
- Movable trim weights (476g each)

### **Required Software**
```bash
pip install opencv-python opencv-contrib-python numpy scipy
```

**Verify installation:**
```bash
python -c "import cv2; print(cv2.__version__)"
python -c "import numpy; print(numpy.__version__)"
python -c "import scipy; print(scipy.__version__)"
```

---

## üöÄ Step-by-Step Execution Guide

### **PHASE 1: Camera Calibration (One-Time Setup)**

#### **Step 1.1: Take Calibration Photos**

**Preparation:**
1. Print a 9√ó6 checkerboard pattern (inner corners)
2. Measure the square size in millimeters (default: 25mm)
3. If your square size differs, edit `calibrate_camera.py` line 7:
   ```python
   SQUARE_SIZE = 25.0  # Change this to your measured value
   ```

**Execution:**
```bash
python take_calibration_photo.py
```

**Instructions:**
1. Hold the checkerboard in front of the camera
2. Move it to **different positions and angles**:
   - Top-left, top-right, bottom-left, bottom-right
   - Center close, center far
   - Tilted at various angles
3. When the **green border** appears (pattern detected), press **`s`** to save
4. Take **15-20 good photos**
5. Press **`q`** to quit

**Output:** Images saved to `data/calib_images/`

**Troubleshooting:**
- **Red border (pattern not detected):**
  - Ensure checkerboard is flat and printed clearly
  - Improve lighting (diffused, no shadows)
  - Adjust distance from camera
  - Verify pattern size matches `PATTERN_SIZE = (9, 6)`

---

#### **Step 1.2: Calibrate Camera**

**Execution:**
```bash
python calibrate_camera.py
```

**What It Does:**
1. Loads all images from `data/calib_images/`
2. Detects checkerboard corners in each image
3. Calculates camera intrinsic matrix and distortion coefficients
4. Computes RMS reprojection error (quality metric)
5. Saves calibration data to `calib/camera_intrinsics.npz`

**Console Output Example:**
```
Found corners in calib_image_0.png
Found corners in calib_image_1.png
...
--- Calibration Results ---
RMS reprojection error: 0.2341
Calibration data saved to calib/camera_intrinsics.npz
```

**Quality Assessment:**
- ‚úÖ **RMS < 1.0 pixel:** Excellent (target achieved: 0.2 pixels)
- ‚ö†Ô∏è **RMS 1.0-2.0 pixels:** Acceptable
- ‚ùå **RMS > 2.0 pixels:** Poor - retake photos with better quality

**Understanding `camera_intrinsics.npz`:**

This file contains two critical arrays:

1. **`mtx` (Camera Matrix)** - 3√ó3 matrix:
   ```
   [fx  0  cx]
   [0  fy  cy]
   [0   0   1]
   ```
   - `fx, fy` = Focal lengths in pixels (X and Y directions)
   - `cx, cy` = Principal point (optical center) in pixels
   - Describes how 3D points project onto 2D image plane

2. **`dist` (Distortion Coefficients)** - 1√ó5 array:
   ```
   [k1, k2, p1, p2, k3]
   ```
   - `k1, k2, k3` = Radial distortion coefficients (barrel/pincushion)
   - `p1, p2` = Tangential distortion coefficients (lens decentering)
   - Used to correct lens distortion ("fisheye" effect)

**Why This File is Critical:**
- All subsequent scripts require this file to:
  - Undistort images (remove lens warping)
  - Accurately transform pixel coordinates to real-world coordinates
  - Enable precise measurements
- **Without this file, `track_wobble.py` will not run!**

**Loading the File (Example):**
```python
import numpy as np
calib_data = np.load('calib/camera_intrinsics.npz')
camera_matrix = calib_data['mtx']     # 3√ó3 camera matrix
dist_coeffs = calib_data['dist']      # 1√ó5 distortion coefficients
```

---

### **PHASE 2: Marker Setup**

#### **Step 2.1: Print ArUco Markers**

**Important:** Use **DICT_4X4_100** dictionary (not DICT_4X4_50)

**Online Generator:**
1. Visit: https://chev.me/arucogen/
2. Settings:
   - Dictionary: `4x4 (100)`
   - Marker IDs: `0, 1, 2, 3, 4`
   - Marker size: `40-50 mm` (recommended)
3. Download and print on white paper
4. Mount on cardboard for rigidity

**Marker Placement:**

```
Physical Setup (Top View):

         Marker 2 (ID=2)
         @ (0, +120mm)
              |
              |
Marker 3 -----+------ Marker 1
@ (-120,0)    |       @ (+120, 0)
            CoR (origin)
              |
         Marker 4 (ID=4)
         @ (0, -120mm)

    Marker 0 (ID=0)
    On CubeSat at CoR
```

**Placement Instructions:**
1. **Marker 0:** Place on top of CubeSat, centered at CoR
2. **Markers 1-4:** Place on table surface:
   - Marker 1: +120mm along +X axis (right)
   - Marker 2: +120mm along +Y axis (up/away)
   - Marker 3: -120mm along -X axis (left)
   - Marker 4: -120mm along -Y axis (down/toward)
3. Ensure all markers are **flat** and **facing camera**
4. Avoid wrinkles, glare, and shadows

**Measuring Your Setup:**
If your marker distance differs from 120mm:
1. Measure the actual distance from CoR to reference markers
2. Edit `track_wobble.py` line 18:
   ```python
   R_REF = 120.0  # Change to your measured distance
   ```

---

#### **Step 2.2: Measure Heights**

**Critical for Accurate Results!**

Measure from the camera lens to each surface:

1. **Z_CAM:** Camera height above table (e.g., 500mm)
2. **Z_TABLE:** Gap from camera to table surface where markers 1-4 sit (e.g., 360mm)
3. **Z_MARKER0:** Gap from camera to top surface of CubeSat where marker 0 sits (e.g., 240mm)

**Visual Diagram:**
```
Camera Lens
    |
    |<--- Z_CAM = 500mm ---->|
    |                        |
    |                     [Table Surface]
    |<- Z_TABLE = 360mm ->|  (Markers 1-4)
    |                        |
    |                    [CubeSat Top]
    |<- Z_MARKER0 = 240mm->| (Marker 0)
```

**Update `track_wobble.py` (Lines 24-26):**
```python
Z_CAM = 500      # Your measured camera height
Z_TABLE = 360    # Your measured table height
Z_MARKER0 = 240  # Your measured marker 0 height
```

**Why Heights Matter:**
The perspective correction formula requires accurate heights:
```python
scale_factor = (Z_CAM - Z_TABLE) / (Z_CAM - Z_MARKER0)
```
Incorrect heights ‚Üí incorrect correction vector ‚Üí poor balancing!

---

#### **Step 2.3: Test Marker Detection (Optional but Recommended)**

**Execution:**
```bash
python basic_detection.py
```

**What to Check:**
- ‚úÖ All 5 markers (IDs 0-4) are detected
- ‚úÖ Red dots appear at marker centers
- ‚úÖ Marker IDs are labeled correctly
- ‚úÖ Detection is stable (no flickering)

**Press `q` to quit**

**If markers not detected:**
1. Check marker dictionary (must be DICT_4X4_100)
2. Improve lighting (diffused, uniform)
3. Flatten markers (remove wrinkles)
4. Increase marker size if too small
5. Check camera focus

---

#### **Step 2.4: Align Camera (Optional)**

**Execution:**
```bash
python Camera_Coordinate_System.py
```

**Purpose:** Visually align camera center with CoR

**Instructions:**
1. Run the script - you'll see live video with coordinate axes
2. The **green dot** at the center represents the camera center
3. Physically move the camera until:
   - Green dot aligns with Marker 0 (CoR)
   - Markers 1-4 are roughly equidistant from center
4. Press `q` when aligned

---

### **PHASE 3: Wobble Tracking & Analysis**

#### **Step 3: Track Wobble & Calculate Correction Vector**

**Preparation:**
1. Ensure `calib/camera_intrinsics.npz` exists
2. Verify all 5 markers are placed correctly
3. **Minimize disturbances:**
   - Turn off AC and fans
   - Close windows
   - Avoid speaking during measurement
   - Ensure stable lighting

**Execution:**
```bash
python track_wobble.py
```

**During Execution (5 seconds):**
- Live video window shows:
  - Marker detection in real-time
  - Colored paths drawn for each marker
  - FPS counter
  - Coordinate axes (+X right, +Y up)

**After Completion:**
Console displays analysis results:
```
--- Analysis Results ---
Fitted Circle Center (Corrected): (-15.52 mm, 9.36 mm)
Fitted Circle Radius (Corrected): 1.31 mm

Correction Vector (Corrected):
  Magnitude: 18.12 mm
  Direction: 148.91 degrees (from +X axis)

Directions: +X is right, +Y is up (on plot). 
Move trim weight in this direction by the indicated amount.
```

**Output Files:**
1. **`data/final_path_plot_pixel.png`**
   - Shows marker paths in pixel coordinates
   - Includes correction vector arrow

2. **`data/final_path_plot_mm.png`**
   - Shows marker 0 path in real-world millimeters
   - **Key elements:**
     - üü° Yellow path: Marker 0 trajectory (wobble)
     - üîµ Blue dot: Fitted circle center (current CoM)
     - üü£ Purple circle: Fitted circle radius (wobble magnitude)
     - ‚ö™ White arrow: Correction vector (direction to move weights)
     - üî¥ Red axes: Coordinate system (+X right, +Y up)
     - üü¢ Green dot: Origin (CoR target)

3. **`data/markers_real_world_log.csv`**
   - Time-series data of marker 0 position in mm
   - Columns: `time, marker_0_x_mm, marker_0_y_mm`

4. **`data/markers_pixel_log.csv`**
   - Time-series data of all markers in pixels
   - Columns: `time, marker_0_px_x, marker_0_px_y, marker_1_px_x, ...`

---

### **PHASE 4: Weight Adjustment & Iteration**

#### **Step 4.1: Calculate Weight Displacement**

**From the console output, note:**
- Fitted Circle Center: `(x_c, y_c)` in mm
- Example: `(-15.52, 9.36)`

**Apply the formula:**
```
Œîx' = -(x_c √ó M_sys) / m
Œîy' = -(y_c √ó M_sys) / m

Where:
M_sys = 8870 g (total system mass)
m = 476 g (each trim weight mass)
```

**Example Calculation:**
```
Given: x_c = -15.52 mm, y_c = 9.36 mm

Œîx' = -(-15.52 √ó 8870) / 476 = +289.1 mm
Œîy' = -(9.36 √ó 8870) / 476 = -174.6 mm

Interpretation:
- Move X-axis weight +289.1 mm (toward +X direction)
- Move Y-axis weight -174.6 mm (toward -Y direction)
```

**Practical Adjustment:**
1. Calculate Œîx' and Œîy'
2. Move the X-axis trim weight by Œîx' distance
3. Move the Y-axis trim weight by Œîy' distance
4. Wait **60 seconds** for system to stabilize
5. Proceed to next measurement

---

#### **Step 4.2: Iterative Balancing**

**Repeat the cycle:**

```bash
# Iteration 1
python track_wobble.py
# Note correction vector, move weights, wait 60s

# Iteration 2
python track_wobble.py
# Note correction vector, move weights, wait 60s

# Iteration 3
python track_wobble.py
# Note correction vector, move weights, wait 60s

# Continue until balanced...
```

**Typical Convergence:**

| Iteration | CoM Offset | Radius | Status |
|-----------|------------|--------|--------|
| Initial   | 18.12 mm   | 1.31 mm | ‚ùå Unbalanced |
| After 1st | 8.41 mm    | 0.85 mm | ‚ö†Ô∏è Improving |
| After 2nd | 5.12 mm    | 0.42 mm | ‚ö†Ô∏è Improving |
| After 3rd | 2.18 mm    | 0.33 mm | ‚úÖ Balanced! |

**Balance Achieved When:**
- ‚úÖ Fitted circle center: `|x| < 3 mm` AND `|y| < 3 mm`
- ‚úÖ Fitted circle radius: `< 0.5 mm`
- ‚úÖ Results consistent across multiple measurements (¬±0.5 mm variation)

---

## üìä Understanding the Results

### **Key Output Parameters**

#### **1. Fitted Circle Center (x, y) [mm]**
- **Physical meaning:** Current CoM location relative to CoR
- **Target:** (0, 0) - perfect alignment
- **Example:** `(-15.52, 9.36)` means:
  - CoM is 15.52 mm to the left of CoR
  - CoM is 9.36 mm above CoR

#### **2. Fitted Circle Radius [mm]**
- **Physical meaning:** Wobble amplitude
- **Target:** ~0 mm (stationary)
- **Interpretation:**
  - `< 0.5 mm` ‚Üí Excellent (near-stationary)
  - `0.5-2 mm` ‚Üí Good (minor wobble)
  - `> 2 mm` ‚Üí Poor (significant wobble)

#### **3. Correction Vector**
- **Magnitude:** Distance CoM needs to move toward CoR
- **Direction:** Angle from +X axis (0¬∞ = right, 90¬∞ = up, 180¬∞ = left, 270¬∞ = down)
- **Example:** `18.12 mm at 148.91¬∞`
  - Move weights to shift CoM 18.12 mm
  - Direction is upper-left quadrant (between +Y and -X)

---

## üîß Troubleshooting

### **Problem 1: "Camera calibration file not found"**

**Error message:**
```
Error: Camera calibration file not found. Please run the calibration script first.
```

**Solution:**
1. Verify `calib/camera_intrinsics.npz` exists
2. If not, run calibration steps 1.1 and 1.2 again
3. Check file path and permissions

---

### **Problem 2: "Not enough data points for Marker 0 to fit a circle"**

**Causes:**
- Marker 0 not detected during measurement
- Too few data points collected

**Solutions:**
1. **Check marker 0 visibility:**
   - Ensure marker 0 is flat and facing camera
   - Improve lighting on marker 0
   - Verify marker 0 is from DICT_4X4_100

2. **Increase capture time:**
   Edit `track_wobble.py` line 20:
   ```python
   RUN_SECONDS = 5  # Try increasing to 10 or 15
   ```

3. **Verify camera calibration:**
   Re-run `basic_detection.py` to check detection quality

---

### **Problem 3: Inconsistent Results Across Measurements**

**Symptoms:**
```
Run 1: Center = (-15.52, 9.36), Radius = 1.31
Run 2: Center = (-4.44, 2.63), Radius = 11.70  ‚Üê Large variation
```

**Causes & Solutions:**

1. **Air disturbances:**
   - ‚úÖ Turn off all ventilation (AC, fans)
   - ‚úÖ Close windows and doors
   - ‚úÖ Avoid speaking during measurement
   - ‚úÖ Remove nearby moving objects

2. **System not stabilized:**
   - ‚úÖ Wait 60 seconds after moving weights
   - ‚úÖ Ensure system reaches stationary state
   - ‚úÖ Reduce `RUN_SECONDS` to 5 (captures steady state)

3. **Measurement during transition:**
   - ‚ùå Don't measure while system is oscillating
   - ‚úÖ Wait for wobble to settle into circular pattern

4. **Height measurements incorrect:**
   - ‚úÖ Re-measure Z_CAM, Z_TABLE, Z_MARKER0
   - ‚úÖ Update values in `track_wobble.py`

---

### **Problem 4: Markers Not Detected**

**Symptoms:**
- "Markers Detected: 0" or "Markers Detected: 2/5"
- Flickering detection

**Solutions:**

1. **Marker Dictionary Mismatch:**
   - `basic_detection.py` uses DICT_4X4_50
   - `track_wobble.py` uses DICT_4X4_100
   - ‚úÖ **Print new markers from DICT_4X4_100 and use those!**

2. **Lighting Issues:**
   - ‚úÖ Use diffused overhead lighting
   - ‚úÖ Avoid shadows and harsh directional light
   - ‚úÖ Eliminate glare on markers (matte finish preferred)

3. **Marker Quality:**
   - ‚úÖ Ensure markers are flat (mount on rigid cardboard)
   - ‚úÖ Check for wrinkles, tears, or dirt
   - ‚úÖ Increase marker size (try 50mm instead of 40mm)
   - ‚úÖ Print with high contrast (black on white)

4. **Camera Issues:**
   - ‚úÖ Check camera focus
   - ‚úÖ Reduce camera offset if > 50cm
   - ‚úÖ Ensure camera is perpendicular to table

---

### **Problem 5: Correction Vector Points Wrong Direction**

**Symptoms:**
- Moving weights according to vector makes balance worse
- Physical intuition doesn't match results

**Causes:**

1. **Coordinate System Confusion:**
   - Check `data/final_path_plot_mm.png`
   - Verify axis labels: +X (right), +Y (up), -X (left), -Y (down)

2. **Incorrect Height Measurements:**
   - Most common cause of wrong correction vectors
   - ‚úÖ Re-measure Z_CAM, Z_TABLE, Z_MARKER0 carefully
   - ‚úÖ Use ruler or tape measure from camera lens downward

3. **Marker Placement Error:**
   - ‚úÖ Verify markers 1-4 are at correct positions
   - ‚úÖ Measure actual R_REF and update in code

---

### **Problem 6: System Becomes Unstable Near Balance**

**Symptoms:**
- After 2-3 iterations, balance gets worse instead of better
- Oscillates around equilibrium

**Explanation:**
- System becomes sensitive to small corrections when nearly balanced
- Small measurement errors have larger relative impact

**Solutions:**

1. **Use Smaller Adjustments:**
   - When CoM offset < 5mm, move weights by 50% of calculated Œîx', Œîy'
   - Example: If Œîx' = 100mm, move only 50mm

2. **Take Multiple Measurements:**
   - Run `track_wobble.py` 3 times without moving weights
   - Average the correction vectors
   - Use averaged result for adjustment

3. **Check for Z-axis Offset:**
   - Current method only corrects XY plane
   - Vertical CoM offset causes pendulum effect
   - May require manual Z-adjustment

---

## üìà Performance Metrics

### **Calibration Quality**
- Target: RMS reprojection error < 1.0 pixel
- Achieved: **0.2 pixels** ‚úÖ

### **Typical Balancing Session**
- **Initial offset:** ~18 mm
- **Final offset:** <3 mm (83% improvement)
- **Number of iterations:** 3-5
- **Time per iteration:** ~5 minutes
- **Total time:** 15-30 minutes

### **Measurement Precision**
- **Repeatability:** ¬±0.3 mm (steady state)
- **Spatial resolution:** ~0.1 mm
- **Angular resolution:** ~1 degree

---

## üéì Technical Details

### **Coordinate Systems**

**Pixel Coordinate System:**
- Origin: Top-left corner of image
- X-axis: Horizontal (left ‚Üí right)
- Y-axis: Vertical (top ‚Üí bottom)
- Units: Pixels

**Real-World Coordinate System:**
- Origin: Center of Rotation (CoR)
- X-axis: Horizontal (left ‚Üí right on table)
- Y-axis: Horizontal (away from camera)
- Units: Millimeters

**Transformation:**
```python
# Step 1: Undistort pixel coordinates
undistorted = cv2.undistortPoints(pixel_coords, camera_matrix, dist_coeffs)

# Step 2: Apply homography (4 reference markers define transformation)
H = cv2.findHomography(ref_pixels, ref_real_world)
real_world = cv2.perspectiveTransform(undistorted, H)

# Step 3: Apply perspective correction
scale = (Z_CAM - Z_TABLE) / (Z_CAM - Z_MARKER0)
corrected = real_world * scale
```

---

### **Why Perspective Correction is Necessary**

**Problem:** Marker 0 is higher than markers 1-4

```
Camera view (without correction):
- Marker 0 appears farther from center than it actually is
- Creates systematic error in CoM calculation

Solution:
- Scale measured coordinates by height ratio
- Corrects for parallax effect
```

**Formula Derivation:**
```
Similar triangles principle:
actual_distance / apparent_distance = (Z_CAM - Z_MARKER0) / (Z_CAM - Z_TABLE)

Therefore:
actual_distance = apparent_distance √ó [(Z_CAM - Z_TABLE) / (Z_CAM - Z_MARKER0)]
```

---

### **Circle Fitting Algorithm**

**Method:** Algebraic least squares

**Objective:** Minimize residual sum of squares
```
min Œ£[(‚àö((x_i - x_c)¬≤ + (y_i - y_c)¬≤) - r)¬≤]
```

**Linear Approximation:**
```
x¬≤ + y¬≤ = 2¬∑x_c¬∑x + 2¬∑y_c¬∑y + (r¬≤ - x_c¬≤ - y_c¬≤)

Rearrange as: Ac = b
where A = [2x, 2y, 1]
      c = [x_c, y_c, r¬≤ - x_c¬≤ - y_c¬≤]
      b = x¬≤ + y¬≤

Solve: c = (A^T A)^(-1) A^T b
```

**Implementation:** `scipy.optimize.least_squares`

---

## üî¨ Validation & Reproducibility

### **To Reproduce Results:**

1. **Hardware Setup:**
   - Camera at ~50cm height
   - Reference markers at exactly 120mm from CoR
   - Marker 0 on CubeSat at CoR

2. **Calibration:**
   - 15-20 checkerboard photos
   - RMS error < 1.0 pixel

3. **Environment:**
   - Controlled lighting (no shadows, no glare)
   - No air disturbances (AC off, windows closed)
   - Stable table surface

4. **Measurement Protocol:**
   - Run `track_wobble.py` 3 times
   - Check consistency (¬±0.5mm variation acceptable)
   - Average results if needed

5. **Expected Results:**
   - Initial: 15-20mm offset
   - After 3 iterations: <3mm offset
   - Radius: <0.5mm

---

## üìö References
